L’authentification avec Spring Security suit plusieurs étapes bien définies. Voici où et quand se passe la vérification du username et du mot de passe.

📌 Étape par Étape de l’Authentification

1️⃣ Le client envoie une requête de login

Quand un utilisateur tente de se connecter, il envoie une requête POST avec son username et password :

POST /auth/login
Content-Type: application/json

{
    "username": "john_doe",
    "password": "mypassword"
}

Le contrôleur (AuthController) passe ensuite ces informations au AuthService :

public ResponseEntity<?> login(@RequestBody AuthRequest authRequest) {
    return authService.authenticateUser(authRequest.getUsername(), authRequest.getPassword());
}

2️⃣ authenticationManager.authenticate(...) est appelé

Dans AuthService, on fait :

Authentication authentication = authenticationManager.authenticate(
    new UsernamePasswordAuthenticationToken(username, password)
);

📌 Que se passe-t-il ici ?
	•	authenticationManager va chercher un AuthenticationProvider capable de traiter ce type de requête.
	•	Par défaut, Spring Security utilise DaoAuthenticationProvider pour les identifiants en base de données.

3️⃣ DaoAuthenticationProvider vérifie les identifiants

Le DaoAuthenticationProvider effectue deux tâches :
	1.	🔍 Charge l’utilisateur en base via UserDetailsService :

UserDetails user = userDetailsService.loadUserByUsername(username);

	•	Cette méthode interroge la base de données et renvoie un objet UserDetails avec les informations de l’utilisateur.
	•	Si l’utilisateur n’existe pas, Spring Security lève une UsernameNotFoundException → Erreur 401.

	2.	🔐 Vérifie le mot de passe :

passwordEncoder.matches(passwordSaisi, passwordStocke);

	•	DaoAuthenticationProvider compare le mot de passe saisi avec celui stocké en base (qui est hashé avec BCrypt).
	•	Si le mot de passe ne correspond pas, Spring Security lève une BadCredentialsException → Erreur 401.

4️⃣ Si l’authentification réussit

Si le username et le mot de passe sont corrects :
	•	Spring Security crée un UsernamePasswordAuthenticationToken qui contient l’utilisateur authentifié et ses rôles.
	•	Cet objet est stocké dans le SecurityContext.

SecurityContextHolder.getContext().setAuthentication(authentication);

Puis, on génère un JWT (access token + refresh token) et on l’envoie en réponse :

String accessToken = jwtUtil.generateAccessToken(user.getUsername());
String refreshToken = jwtUtil.generateRefreshToken(user.getUsername());

return ResponseEntity.ok(Map.of(
    "accessToken", accessToken,
    "refreshToken", refreshToken,
    "message", "Authentification réussie"
));

📌 Résumé du Processus
	1.	Le client envoie username et password via un POST /auth/login.
	2.	authenticationManager.authenticate(...) est appelé.
	3.	DaoAuthenticationProvider demande UserDetailsService.loadUserByUsername(username) :
	•	Si l’utilisateur n’existe pas → Erreur 401.
	4.	Spring Security compare le mot de passe avec BCrypt :
	•	Si incorrect → Erreur 401.
	5.	Si tout est OK, Spring Security crée une session et génère un JWT.

📌 Où exactement a lieu la vérification ?

✅ La recherche du username est faite dans UserDetailsService.loadUserByUsername(username).
✅ La vérification du mot de passe est faite dans DaoAuthenticationProvider, en comparant avec BCrypt.
✅ Si tout est bon, l’utilisateur est authentifié et un JWT est généré.

Tu veux ajouter un refresh token automatique sans endpoint /refresh ?