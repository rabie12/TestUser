    Dâ€™accord ! On va dÃ©placer toute la logique dâ€™authentification et de vÃ©rification LDAP dans un service dÃ©diÃ©. Le contrÃ´leur ne fera quâ€™appeler ce service et renvoyer la rÃ©ponse.

ðŸ“Œ Ã‰tape 1 : Service dâ€™Authentification

On crÃ©e un AuthService qui gÃ¨re :
	â€¢	VÃ©rification du groupe LDAP avant authentification.
	â€¢	Authentification avec AuthenticationManager.
	â€¢	GÃ©nÃ©ration et retour des tokens.

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
public class AuthService {

    private final AuthenticationManager authenticationManager;
    private final JwtUtil jwtUtil;
    private final LdapGroupChecker ldapGroupChecker;
    private final MyUserDetailsService userDetailsService;

    public AuthService(AuthenticationManager authenticationManager, JwtUtil jwtUtil, 
                       LdapGroupChecker ldapGroupChecker, MyUserDetailsService userDetailsService) {
        this.authenticationManager = authenticationManager;
        this.jwtUtil = jwtUtil;
        this.ldapGroupChecker = ldapGroupChecker;
        this.userDetailsService = userDetailsService;
    }

    public ResponseEntity<?> authenticateUser(String username, String password) {
        // ðŸ” VÃ©rifie si l'utilisateur appartient au groupe LDAP
        if (!ldapGroupChecker.isUserInGroup(username, "admins")) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body(Map.of("error", "AccÃ¨s refusÃ© : vous n'Ãªtes pas autorisÃ©."));
        }

        try {
            // ðŸ” Authentification avec Spring Security
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(username, password));

            UserDetails user = userDetailsService.loadUserByUsername(username);

            // ðŸŽ« GÃ©nÃ©ration des tokens JWT
            String accessToken = jwtUtil.generateAccessToken(user.getUsername());
            String refreshToken = jwtUtil.generateRefreshToken(user.getUsername());

            return ResponseEntity.ok(Map.of(
                    "accessToken", accessToken,
                    "refreshToken", refreshToken,
                    "message", "Authentification rÃ©ussie"
            ));
        } catch (BadCredentialsException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(Map.of("error", "Nom d'utilisateur ou mot de passe incorrect"));
        }
    }
}

ðŸ“Œ Ã‰tape 2 : VÃ©rification LDAP

CrÃ©ation dâ€™un service LdapGroupChecker pour vÃ©rifier si un utilisateur appartient Ã  un groupe.

import org.springframework.ldap.core.LdapTemplate;
import org.springframework.ldap.query.LdapQuery;
import org.springframework.ldap.query.LdapQueryBuilder;
import org.springframework.stereotype.Service;

@Service
public class LdapGroupChecker {

    private final LdapTemplate ldapTemplate;

    public LdapGroupChecker(LdapTemplate ldapTemplate) {
        this.ldapTemplate = ldapTemplate;
    }

    public boolean isUserInGroup(String username, String group) {
        LdapQuery query = LdapQueryBuilder.query()
                .base("ou=groups,dc=example,dc=com") // Adapte selon ton LDAP
                .where("objectClass").is("groupOfNames")
                .and("cn").is(group)
                .and("member").is("uid=" + username + ",ou=users,dc=example,dc=com");

        return ldapTemplate.find(query, String.class).size() > 0;
    }
}

ðŸ“Œ Ã‰tape 3 : ContrÃ´leur SimplifiÃ©

Le contrÃ´leur (AuthController) ne fait plus rien dâ€™autre que dâ€™appeler le service.

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/auth")
public class AuthController {

    private final AuthService authService;

    public AuthController(AuthService authService) {
        this.authService = authService;
    }

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody AuthRequest authRequest) {
        return authService.authenticateUser(authRequest.getUsername(), authRequest.getPassword());
    }
}

ðŸ“Œ RÃ©sumÃ©

âœ… Tout est dans AuthService : gestion des groupes, authentification et gÃ©nÃ©ration des tokens.
âœ… Le contrÃ´leur est minimaliste : il dÃ©lÃ¨gue tout au service.
âœ… Meilleure organisation du code, facile Ã  maintenir et tester.

Tu veux ajouter une configuration dynamique des groupes autorisÃ©s via application.yml ?