D‚Äôaccord ! On va corriger le probl√®me de search avec LDAP et ajouter un hash s√©curis√© des mots de passe avant stockage en base de donn√©es.

üõ† 1. Correction de la m√©thode search dans LDAP

Si la m√©thode ldapTemplate.search(...) n‚Äôest pas reconnue, assure-toi que tu as bien import√© :

import org.springframework.ldap.core.LdapTemplate;
import org.springframework.ldap.query.LdapQuery;
import org.springframework.ldap.query.LdapQueryBuilder;

Puis, modifie ton service LDAP comme ceci :

import org.springframework.ldap.core.LdapTemplate;
import org.springframework.ldap.core.support.LdapContextSource;
import org.springframework.ldap.query.LdapQuery;
import org.springframework.ldap.query.LdapQueryBuilder;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class LdapService {
    private final LdapTemplate ldapTemplate;

    public LdapService(LdapTemplate ldapTemplate) {
        this.ldapTemplate = ldapTemplate;
    }

    public boolean isUserInGroup(String username, String groupName) {
        LdapQuery query = LdapQueryBuilder.query()
                .base("ou=groups,dc=example,dc=com")
                .where("cn").is(groupName)
                .and("member").is("cn=" + username + ",ou=users,dc=example,dc=com");

        List<String> result = ldapTemplate.search(query, (attributes, name) -> name.toString());
        return !result.isEmpty();
    }
}

‚úÖ V√©rifie que ta d√©pendance spring-boot-starter-ldap est bien incluse dans ton pom.xml :

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-ldap</artifactId>
</dependency>

üîê 2. Hashage s√©curis√© des mots de passe

üîπ Utiliser BCrypt pour hasher les mots de passe

BCrypt est recommand√© car il ajoute un salt automatiquement et ralentit les attaques par force brute.

Ajoute cette d√©pendance (si elle n‚Äôest pas d√©j√† incluse) :

<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-crypto</artifactId>
</dependency>

Puis, cr√©e un service pour g√©rer les mots de passe :

import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
public class PasswordService {
    private final PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    public String hashPassword(String password) {
        return passwordEncoder.encode(password);
    }

    public boolean verifyPassword(String rawPassword, String hashedPassword) {
        return passwordEncoder.matches(rawPassword, hashedPassword);
    }
}

‚úÖ Explication :
	1.	hashPassword(String password) ‚Üí Prend un mot de passe en clair et le hash avec BCrypt.
	2.	verifyPassword(String rawPassword, String hashedPassword) ‚Üí V√©rifie si un mot de passe correspond au hash.

üóÑÔ∏è 3. Stockage s√©curis√© en base de donn√©es

Ajoute un mod√®le d‚Äôutilisateur avec un champ password :

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Getter
@Setter
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;
    private String password; // Hash√© avec BCrypt
    private String role;
}

Puis, cr√©e un repository JPA pour manipuler les utilisateurs :

import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
}

üîê 4. Enregistrement d‚Äôun utilisateur avec hashage du mot de passe

Cr√©e un service pour enregistrer un nouvel utilisateur :

import org.springframework.stereotype.Service;

@Service
public class UserService {
    private final UserRepository userRepository;
    private final PasswordService passwordService;

    public UserService(UserRepository userRepository, PasswordService passwordService) {
        this.userRepository = userRepository;
        this.passwordService = passwordService;
    }

    public User registerUser(String username, String rawPassword, String role) {
        User user = new User();
        user.setUsername(username);
        user.setPassword(passwordService.hashPassword(rawPassword)); // Hash du mot de passe
        user.setRole(role);

        return userRepository.save(user);
    }
}

üöÄ 5. Endpoint pour enregistrer un utilisateur

Ajoute un contr√¥leur pour cr√©er un nouvel utilisateur via une requ√™te HTTP :

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/users")
public class UserController {
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @PostMapping("/register")
    public String register(@RequestParam String username, @RequestParam String password, @RequestParam String role) {
        userService.registerUser(username, password, role);
        return "Utilisateur enregistr√© avec succ√®s !";
    }
}

‚úÖ Test avec une requ√™te HTTP (Postman ou Curl)

curl -X POST "http://localhost:8080/users/register" \
     -d "username=testuser&password=monmotdepasse&role=USER"

üîë 6. V√©rification du mot de passe lors de l‚Äôauthentification

Ajoute une m√©thode pour authentifier un utilisateur :

import org.springframework.stereotype.Service;

@Service
public class AuthService {
    private final UserRepository userRepository;
    private final PasswordService passwordService;
    private final JwtUtil jwtUtil;

    public AuthService(UserRepository userRepository, PasswordService passwordService, JwtUtil jwtUtil) {
        this.userRepository = userRepository;
        this.passwordService = passwordService;
        this.jwtUtil = jwtUtil;
    }

    public String authenticate(String username, String rawPassword) {
        return userRepository.findByUsername(username)
                .filter(user -> passwordService.verifyPassword(rawPassword, user.getPassword()))
                .map(user -> jwtUtil.generateToken(username))
                .orElseThrow(() -> new RuntimeException("Identifiants incorrects"));
    }
}

Puis, mets √† jour le contr√¥leur d‚Äôauthentification pour accepter un mot de passe :

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/auth")
public class AuthController {
    private final AuthService authService;

    public AuthController(AuthService authService) {
        this.authService = authService;
    }

    @PostMapping("/login")
    public String login(@RequestParam String username, @RequestParam String password) {
        return authService.authenticate(username, password);
    }
}

üõ† 7. S√©curit√© suppl√©mentaire : configuration JWT avec un secret s√©curis√©

Ajoute ces variables dans application.properties :

jwt.secret=${JWT_SECRET}
jwt.expiration=86400000  # 1 jour en millisecondes

Puis, d√©finis une variable d‚Äôenvironnement dans ton syst√®me :

export JWT_SECRET="unecl√©tr√®ss√©curis√©e"

‚úÖ R√©sum√©
	1.	Correction de search dans LDAP pour r√©cup√©rer les groupes
	2.	Ajout d‚Äôun champ password √† l‚Äôutilisateur
	3.	Hashage s√©curis√© avec BCrypt avant stockage
	4.	V√©rification du mot de passe lors de l‚Äôauthentification
	5.	G√©n√©ration d‚Äôun JWT apr√®s login

üî• Avec √ßa, tu as un syst√®me s√©curis√© combinant LDAP + JWT + un stockage s√©curis√© des mots de passe !

Besoin d‚Äôajustements ou d‚Äôexplications suppl√©mentaires ?