Pour g√©rer le refresh token automatiquement sans endpoint /refresh, on va suivre cette approche :
	‚Ä¢	üîç V√©rifier le refresh token √† chaque requ√™te.
	‚Ä¢	‚ôªÔ∏è G√©n√©rer un nouvel access token automatiquement si le refresh token est valide.
	‚Ä¢	‚ùå D√©connecter l‚Äôutilisateur si le refresh token est expir√©.

üìå √âtape 1 : Modifier JwtUtil pour g√©rer les deux tokens

On va ajouter la gestion du refresh token en plus de l‚Äôaccess token.

import io.jsonwebtoken.*;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;
import java.util.function.Function;

@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secretKey;

    @Value("${jwt.access.expiration}")
    private long accessExpiration; // Ex: 15 min (900000 ms)

    @Value("${jwt.refresh.expiration}")
    private long refreshExpiration; // Ex: 7 jours (604800000 ms)

    private Key getSigningKey() {
        return Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey));
    }

    public String generateAccessToken(String username) {
        return Jwts.builder()
                .subject(username)
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + accessExpiration))
                .signWith(getSigningKey(), Jwts.SIG.HS256)
                .compact();
    }

    public String generateRefreshToken(String username) {
        return Jwts.builder()
                .subject(username)
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + refreshExpiration))
                .signWith(getSigningKey(), Jwts.SIG.HS256)
                .compact();
    }

    public boolean isTokenValid(String token) {
        try {
            Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token);
            return true;
        } catch (JwtException e) {
            return false;
        }
    }

    public boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    private <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        Claims claims = Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
        return claimsResolver.apply(claims);
    }
}

üìå √âtape 2 : Filtre JWT pour g√©rer l‚Äôauto-refresh

On va intercepter chaque requ√™te et v√©rifier les tokens.
Si l‚Äôaccess token est expir√©, on le renouvelle avec le refresh token.

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpHeaders;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final UserDetailsService userDetailsService;

    public JwtAuthenticationFilter(JwtUtil jwtUtil, UserDetailsService userDetailsService) {
        this.jwtUtil = jwtUtil;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {

        String authHeader = request.getHeader(HttpHeaders.AUTHORIZATION);
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            chain.doFilter(request, response);
            return;
        }

        String token = authHeader.substring(7);
        String username = jwtUtil.extractUsername(token);

        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);

            if (jwtUtil.isTokenValid(token)) {
                // ‚úÖ Access token valide, on authentifie l'utilisateur
                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authentication);

            } else if (!jwtUtil.isTokenValid(token) && jwtUtil.isTokenValid(request.getHeader("Refresh-Token"))) {
                // ‚ôªÔ∏è Access token expir√© mais refresh token valide, on le renouvelle
                String newAccessToken = jwtUtil.generateAccessToken(username);
                response.setHeader("New-Access-Token", newAccessToken);
            } else {
                // ‚ùå Tokens invalides ‚Üí D√©connexion
                SecurityContextHolder.clearContext();
                response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Session expir√©e, veuillez vous reconnecter.");
                return;
            }
        }

        chain.doFilter(request, response);
    }
}

üìå √âtape 3 : Configuration de Spring Security

On enregistre notre filtre JWT avant le filtre UsernamePasswordAuthenticationFilter.

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import java.util.List;

@Configuration
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeHttpRequests()
                .requestMatchers("/auth/login", "/users/create").permitAll()
                .anyRequest().authenticated()
            .and()
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
}

üìå √âtape 4 : Envoyer les tokens au Frontend

Lorsqu‚Äôun utilisateur se connecte, on lui envoie l‚Äôaccess token et le refresh token.

public ResponseEntity<?> login(@RequestBody AuthRequest authRequest) {
    Authentication authentication = authenticationManager.authenticate(
        new UsernamePasswordAuthenticationToken(authRequest.getUsername(), authRequest.getPassword())
    );

    String accessToken = jwtUtil.generateAccessToken(authRequest.getUsername());
    String refreshToken = jwtUtil.generateRefreshToken(authRequest.getUsername());

    return ResponseEntity.ok()
            .header("Authorization", "Bearer " + accessToken)
            .header("Refresh-Token", refreshToken)
            .body(Map.of("message", "Authentification r√©ussie"));
}

üìå üöÄ R√©sum√©

‚úÖ Spring Security v√©rifie l‚Äôaccess token √† chaque requ√™te.
‚úÖ Si l‚Äôaccess token expire mais que le refresh token est encore valide, un nouveau access token est g√©n√©r√©.
‚úÖ Si les deux tokens sont invalides, l‚Äôutilisateur est d√©connect√©.
‚úÖ Les tokens sont envoy√©s dans les headers Authorization et Refresh-Token.

üî• Cette approche permet de rafra√Æchir le token automatiquement sans endpoint /refresh !
Tu veux que j‚Äôajoute une gestion des r√¥les avanc√©e ? üîê